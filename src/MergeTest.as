package {		[SWF(width="1168", height="700", frameRate="60")]		import away3d.entities.Mesh;	import away3d.containers.View3D;	import away3d.containers.ObjectContainer3D;	import away3d.cameras.lenses.PerspectiveLens;	import away3d.cameras.Camera3D;	import away3d.materials.BitmapMaterial;	import away3d.debug.AwayStats;	import away3d.lights.PointLight;	import away3d.tools.Merge;	import away3d.primitives.Cube;	import away3d.primitives.Sphere;	import away3d.primitives.Plane;	import away3d.core.base.Object3D;	import away3d.core.base.Geometry;	 	import flash.display.MovieClip;	import flash.display.BitmapData;	import flash.geom.Vector3D;	import flash.events.Event;	import flash.net.URLRequest;		public class MergeTest extends MovieClip	{ 		private var _view : View3D;		private var camera:Camera3D;		private var origin:Vector3D = new Vector3D(0,0,0);		private var wave:Number = 0;		private var _light1:PointLight;		private var _light2:PointLight;		 		public function MergeTest():void		{			addEventListener(Event.ADDED_TO_STAGE, init);		}		 		private function init(e:Event):void		{			removeEventListener(Event.ADDED_TO_STAGE, init);			initView();			addLights();						//COMMENT //UNCOMMENT example methods at will.						// if you need to duplicate many meshes in a loop or many different meshes.			populateWithVectors();			//another example			//populateWithVectorsMass();						// if you want to merge a full container, for instance after a model load or to have an object "forest" from merge with trees models.			//populateWithContainer();						// if you want to merge meshes one by one.			//it is recommanded to use applyToContainer of applyToMeshes when you have more meshes for better performance			//singleMerge();						// using clones or empty mesh reciever			//populateWithClones();			 			this.addEventListener(Event.ENTER_FRAME, handleEnterFrame);		}		 		private function addLights():void		{			_light1 = new PointLight();			_light1.x = -4000;			_light1.y = 6000;			_light1.z = -4000;			_light1.radius = 8000;			_light1.fallOff = 15000;			_light1.color = 0xFF9900; 			_view.scene.addChild(_light1);						_light2 = new PointLight();			_light2.x = 4000;			_light2.y = 2000;			_light2.z = 4000;			_light2.radius = 8000;			_light2.fallOff = 15000;			_light2.color = 0xFFFFFF; 			_view.scene.addChild(_light2);		}				private function initView():void		{			_view = new View3D();			_view.antiAlias = 2;			_view.backgroundColor = 0x333333;			camera = _view.camera;			camera.lens = new PerspectiveLens();			camera.x = 500;			camera.y = 120;			camera.z = 500;			addChild(_view);			addChild(new AwayStats(_view));			 			camera.lens.near = 10;			camera.lens.far = 15000;		}				private function populateWithVectorsMass() : void 		{ 			var merge:Merge = new Merge(false, true);						var bmd:BitmapData = new BitmapData(128,128,false,0xFF00FF); 			var mat:BitmapMaterial = new BitmapMaterial(bmd,true,false,true); 			mat.lights = [_light1, _light2]; 			mat.bothSides  = true; 						var meshes:Vector.<Mesh> = new Vector.<Mesh>(); 						var plane:Plane; 						var _rows : Number = 20;  			var _space : Number = 2; 			var _wh : Number = 50; 						var z:uint; 			var y:uint; 			var x:uint; 			for (z = 0;z < _rows; ++z) { 				for (y= 0;y < _rows;++y) { 					for (x = 0;x < _rows;++x) { 						  plane  = new Plane(null,_wh*2,_wh*2,1,1,true);       						  plane.x = -(_rows*(_wh+_space)*0.5) + x * _wh * 2 + (x*_space); 						  plane.y = -(_rows*(_wh+_space)*0.5) + y * _wh * 2 + (y*_space); 						  plane.z = -(_rows*(_wh+_space)*0.5) + z * _wh * 2 + (z*_space); 						  meshes.push(Mesh(plane)); 					} 				} 			} 			var meshResult:Mesh = merge.applyToMeshes(Mesh(meshes.shift()), meshes);			meshResult.material = mat;		   _view.scene.addChild(meshResult); 		} 		 		private function populateWithVectors() : void		{			var iteration : uint = 20; 			var increase : Number = 200;			var offset:Number = -((increase *iteration) *.5);			 			var merge:Merge = new Merge(false, false);			 			var bmd:BitmapData = new BitmapData(64,64,false,0xFF00FF);			var mat:BitmapMaterial = new BitmapMaterial(bmd,true,false,true);			mat.lights = [_light1, _light2];						var sphere : Sphere; 			var sphereReceiver : Sphere; 						var meshes:Vector.<Mesh> = new Vector.<Mesh>();			var i:uint;			var scaleIncrease:Number = .1;			var nscale:Number = 0.2;			for (i = 0;i < iteration; ++i) {				sphere = new Sphere(mat, 100*nscale, 6, 6);				sphere.x = offset + (i*increase);				sphere.y = Math.sin(sphere.x)*100;				meshes.push(Mesh(sphere));								nscale+=scaleIncrease;			}       			_view.scene.addChild(merge.applyToMeshes(Mesh(meshes.shift()), meshes));		}				private function populateWithContainer() : void		{			var _rows : Number = 8; 			var _space : Number = 250;			var _radius : Number = 200;						//we do not keep the materials, we want to clear the sources			var merge:Merge = new Merge(false,true);			 			var sphere : Sphere; 			var container:ObjectContainer3D = new ObjectContainer3D();						var z:uint;			var y:uint;			var x:uint;            for (z = 0;z < _rows; ++z) {                for (y= 0;y < _rows;++y) {                    for (x = 0;x < _rows;++x) {						sphere = new Sphere(null, _radius, 6, 6, true ); 						sphere.x = -(_rows*(_radius+_space)*0.5) + x * _radius * 2 + (x*_space);						sphere.y = -(_rows*(_radius+_space)*0.5) + y * _radius * 2 + (y*_space);						sphere.z = -(_rows*(_radius+_space)*0.5) + z * _radius * 2 + (z*_space);						container.addChild(sphere);                    }                }            }            			var mergedMesh:Mesh = merge.applyToContainer(container, "myMergedMesh");						var bmd:BitmapData = new BitmapData(64,64,false,0xFF00FF);			var mat:BitmapMaterial = new BitmapMaterial(bmd,true,false,true);			mat.lights = [_light1, _light2];						mergedMesh.material = mat;			_view.scene.addChild(mergedMesh);		}				private function singleMerge() : void		{			//we want to keep the materials different and clear the source			var merge:Merge = new Merge(true, true);						var matcube:BitmapMaterial = new BitmapMaterial(new BitmapData(256,256, false, 0xFF0000));			var matcube1:BitmapMaterial = new BitmapMaterial(new BitmapData(256,256, false, 0x0000FF));			matcube.lights = [_light1, _light2];			matcube1.lights = [_light1, _light2];			 			var cube1:Cube = new Cube(matcube, 800, 400, 100);			var cube2:Cube = new Cube(matcube1, 800, 400, 100);						cube1.x = 600;			cube2.x = -600;			cube1.z = cube2.z = 0;			cube1.y = cube2.y = 0;						//here an example where the reciever as scale and rotations			cube1.rotationY = -45;			cube2.rotationY = 45;						cube1.scaleY = 2;			cube2.scaleY = 2;			 			merge.apply(cube1, cube2);			_view.scene.addChild(cube1);			 			// the same settings but higher on y not merge to check results, shown here in green			var matcube2:BitmapMaterial = new BitmapMaterial(new BitmapData(256,256, false, 0x00FF00));			matcube2.lights = [_light1, _light2];			var cube3:Cube = new Cube(matcube2, 800, 400, 100);			var cube4:Cube = new Cube(matcube2, 800, 400, 100);						cube3.x = 600;			cube4.x = -600;			cube3.z = cube4.z = 0;			cube3.y = cube4.y = 800;						cube3.rotationY = -45;			cube4.rotationY = 45;						cube3.scaleY = 2;			cube4.scaleY = 2;			 			_view.scene.addChild(cube3);			_view.scene.addChild(cube4);			 		}				private function populateWithClones() : void		{			var merge:Merge = new Merge(true, true);						var matcube:BitmapMaterial = new BitmapMaterial(new BitmapData(256,256, false, 0xFF0000));			matcube.lights = [_light1, _light2];			 			var cube:Cube = new Cube(matcube, 800, 400, 100);			var meshes:Vector.<Mesh> = new Vector.<Mesh>();						//case with empty mesh			var reciever:Mesh = new Mesh();			var cubeclone:Mesh;			var i:uint;			var iteration : uint = 20; 			var increase : Number = 200;			var offset:Number = -((increase *iteration) *.5);			 			for (i = 0;i < iteration; ++i) {				cubeclone = cube.clone() as Mesh;				cubeclone.x = offset + (i*increase);				cubeclone.y = i*50;				meshes.push(cubeclone);			}       		//as we set keepmaterial, the reciever gets the cube clone material			_view.scene.addChild(merge.applyToMeshes(reciever, meshes));		}				private function handleEnterFrame(e : Event) : void		{			_view.camera.position = origin;			_view.camera.rotationY += 1;			_view.camera.moveBackward(4000);						 wave+= .02;			_view.camera.y =  600*Math.sin(wave);			camera.lookAt(origin); 			 			_view.render();		}		 	}}