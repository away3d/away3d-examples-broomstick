package{	import away3d.containers.*;	import away3d.lights.DirectionalLight;	import away3d.lights.LightBase;	import away3d.lights.PointLight;	import away3d.materials.AnimatedBitmapMaterial;	import away3d.materials.BitmapMaterial;	import away3d.primitives.Cube;	import away3d.primitives.Plane;	import away3d.containers.ObjectContainer3D;		import flash.display.BitmapData;	import flash.display.Sprite;	import flash.display.MovieClip;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.events.Event;	import flash.utils.getTimer;		import flash.filters.DisplacementMapFilter;	import flash.filters.BlurFilter;	import flash.geom.Point;	[SWF(width="800", height="600", frameRate="60", backgroundColor="#000000")]			public class AnimatedBitmapMaterialTest extends Sprite	{		private var _view : View3D;		private var _ctr : ObjectContainer3D;		private var _light : PointLight;		private var _seaAnim:AnimatedBitmapMaterial;		 		[Embed(source="assets/models/textures/sea.jpg")]		private var SeaImage : Class;				[Embed(source="assets/models/textures/sea_NRM.png")]		private var SeaImageNRM : Class;		 		public function AnimatedBitmapMaterialTest()		{			addEventListener(Event.ADDED_TO_STAGE, init);		}		private function init(e:Event):void		{			initView();			initObjects();			this.addEventListener(Event.ENTER_FRAME, _handleEnterFrame);		}				private function initView():void		{			_view = new View3D();						this.addChild(_view);			_view.camera.x = 50;			_view.camera.y = 100;			_view.camera.z = -800;			 			_light = new PointLight();			_light.x = -1000;			_light.y = 1000;			_light.z = -1000;			_light.radius = 1000;			_light.fallOff = 4000;			_light.color = 0x66FFFFF; 			_view.scene.addChild(_light);						stage.scaleMode = StageScaleMode.NO_SCALE;			stage.align = StageAlign.TOP_LEFT;			stage.addEventListener(Event.RESIZE, onStageResize);        }				private function initObjects():void		{			var waterBmd:BitmapData = new SeaImage().bitmapData;			var maps:Array = generateSequence(waterBmd, 64);						var waterNMBmd:BitmapData = new SeaImageNRM().bitmapData;			var normalMaps:Array = generateSequence(waterNMBmd, 64);			//in this example we do not pass a movieClip, we generate a series of bitmapdata via code			// and use the setFrames method instead.			//Replace the null by a movieclip with 1 or more frames if you want to generate from an animation stored in a movieclip			// call then would be: _seaAnim = new AnimatedBitmapMaterial(myMc, true, false, 0);						_seaAnim = new AnimatedBitmapMaterial(null, true, false, 0, waterBmd);			_seaAnim.setMaps(maps);			_seaAnim.setNormalMaps(normalMaps);			_seaAnim.play();			_seaAnim.lights = [_light];			 			_ctr = new ObjectContainer3D();			var plane:Plane = new Plane(_seaAnim, 1000, 1000, 10, 10);			_ctr.addChild(plane);			var plane2:Plane = new Plane(_seaAnim, 1000, 1000, 10, 10);			plane2.rotationY = 180;			_ctr.addChild(plane2);						var cube:Cube = new Cube();			cube.material = _seaAnim;			cube.y += 50;			_ctr.addChild(cube);			_view.scene.addChild(_ctr);		}				private function generateSequence(sourceWater:BitmapData, copies:int = 1):Array		{			var watersources:Array = [];			var frames:Array = []; 			var dubWater:BitmapData = sourceWater.clone();			var perlinmap:BitmapData = sourceWater.clone();			var dmf:DisplacementMapFilter = new DisplacementMapFilter(perlinmap, new Point(0, 0), 1, 1, 8, 8, "wrap");			var bf:BlurFilter = new BlurFilter(4,4);			var pt1:Point = new Point(0,0);			var pt2:Point = new Point(0,0);			var ptzero:Point = new Point(0,0);			var perlinOffsets:Array = [pt1, pt2];						var frame:BitmapData;			for(var i:uint = 0; i<copies; ++i){				sourceWater.copyPixels(dubWater,dubWater.rect,ptzero);				perlinOffsets[0].x += 8;				perlinOffsets[1].y += 2;									perlinmap.perlinNoise(256, 32, 2, 2, true, false, 2, true, perlinOffsets);				dmf.mapBitmap = perlinmap;				sourceWater.applyFilter(sourceWater, sourceWater.rect,ptzero,dmf);				sourceWater.applyFilter(sourceWater, sourceWater.rect,ptzero,bf);				sourceWater.draw(sourceWater,null,null,"hardlight",sourceWater.rect,true);				frame = sourceWater.clone();				watersources.push(frame);			}						watersources = watersources.concat(frames.reverse());			dubWater.dispose();			perlinmap.dispose();			dmf = null;						return watersources;		}		private function onStageResize(event : Event) : void		{			_view.width = stage.stageWidth;			_view.height = stage.stageHeight;		}				private function _handleEnterFrame(ev : Event) : void		{			_ctr.rotationY += 1;			_view.render();		}	}}