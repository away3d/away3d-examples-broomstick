package {		[SWF(width="1168", height="700", frameRate="60")]		import away3d.entities.Mesh;	import away3d.containers.View3D;	import away3d.containers.ObjectContainer3D;	import away3d.cameras.lenses.PerspectiveLens;	import away3d.cameras.Camera3D;	import away3d.materials.BitmapMaterial;	import away3d.debug.AwayStats;	import away3d.lights.PointLight;	import away3d.lights.LightBase;	import away3d.primitives.Cube;	import away3d.extrusions.DelaunayMesh;	import away3d.tools.MeshDebugger;	import away3d.materials.ColorMaterial;	import away3d.debug.Trident;	 	import flash.display.MovieClip;	import flash.display.BitmapData;	import flash.geom.Vector3D;	import flash.events.Event;	 	public class DelaunayMeshTest extends MovieClip	{ 		[Embed(source="assets/models/images/orang.jpg")]		private var Diffuse : Class;		private var _view : View3D;		private var camera:Camera3D;		private var origin:Vector3D = new Vector3D(0,0,0);		private var _wave:Number = 0;		private var _light1:PointLight;		private var _light2:PointLight;				public function DelaunayMeshTest():void		{			addEventListener(Event.ADDED_TO_STAGE, init);		}		 		private function init(e:Event):void		{			removeEventListener(Event.ADDED_TO_STAGE, init);			initView();			addLights();			generateFromVectorCloud();			 			this.addEventListener(Event.ENTER_FRAME, handleEnterFrame);		}		 		private function addLights():void		{			_light1 = new PointLight();			_light1.x = -500;			_light1.y = -1000;			_light1.z = -500;			_light1.radius = 8000;			_light1.fallOff = 15000;			_light1.color = 0xFF9900;			 			_view.scene.addChild(_light1);						_light2 = new PointLight();			_light2.x = 500;			_light2.y = 1000;			_light2.z = 500;			_light2.radius = 8000;			_light2.fallOff = 15000;			_light2.color = 0xFFFFFF; 			_view.scene.addChild(_light2);		}				private function initView():void		{			_view = new View3D();			_view.antiAlias = 2;			_view.backgroundColor = 0x333333;			camera = _view.camera;			camera.lens = new PerspectiveLens();			camera.x = 500;			camera.y = 120;			camera.z = 500;			addChild(_view);			addChild(new AwayStats(_view));			 			camera.lens.near = 10;			camera.lens.far = 5000;		}		 		private function generateFromVectorCloud() : void		{ 			var mat:BitmapMaterial = new BitmapMaterial(new Diffuse().bitmapData);			mat.lights = [_light1, _light2];			mat.bothSides = true;			 			var vectors:Vector.<Vector3D> = new Vector.<Vector3D>();			var max:Number = 500;			var hmax:Number = max*.5;			 			var cube:Cube;			var matVectors:ColorMaterial = new ColorMaterial(0xFF0000);			var size:Number = 20;						for(var i:uint = 0; i<50; ++i){				vectors[i] = new Vector3D(-hmax+Math.random()*max,  Math.random()*20, -hmax+Math.random()*max);				cube = new Cube(matVectors, size, size, size);				cube.position = vectors[i];			}			 			//material : MaterialBase, vectors:Vector.<Vector3D>, plane:String = , centerMesh:Boolean = false, flip:Boolean = false, smoothSurface:Boolean = true			var delaunayMesh:DelaunayMesh = new DelaunayMesh(mat, vectors, DelaunayMesh.PLANE_XZ, false, false, true);			_view.scene.addChild(delaunayMesh);						//using the MeshDebugger class to inspect in this case the normals and vertexNormals of the newly created mesh			var meshDebugger:MeshDebugger = new MeshDebugger();			meshDebugger.debug(Mesh(delaunayMesh), _view.scene, true, true, false);			 			// using the Trident class 			var trident:Trident = new Trident(500, true);			_view.scene.addChild(trident);					}		 		private function handleEnterFrame(e : Event) : void		{			_view.camera.position = origin;			_view.camera.rotationY += .5;			_view.camera.moveBackward(900);						_wave+= .005;			_view.camera.y =  400+Math.sin(_wave)*200;			 			camera.lookAt(origin);			 			_view.render();		}		 	}}